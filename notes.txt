These are stream of thought notes as the system is implemented. When this file
starts, the scanner is already implemented and somewhat tested. This file
contains thanges that are made and thoughts about the implementation and
languiage as they appear.

--------------
Deleted the namespace keyword. It's redundant. When an import is made, then
the import name is used. If a class is not imported, then there is no need
for an additional name to identify it. The default scope for a class is
private. All import names are private.

----------------
Imports only bring in the name space from the file that is imported. Only
one level of imported names is allowed. In other words, an import can only
bring in names that it defines. It cannot bring in an imported import.

When a module imports another, the imported module can import other modules,
but they don't appear in the symbol table of the one that imported the
other. The importer invokes the compiler to convert the source code into C
and imports the public symbols from the classes that are imported.

There needs to be some smarts in this mechanism that does not rebuild a
module every time it is imported, but it needs to be available to the C
compiler and linker.

The importer needs to keep a database of the importable names and where to find
the source code associated with it. A search mechanism looks for a file in
specific places in the user's source and in the system. The compiled version
(using the -c option) is kept by the system to avoid building it again. This
database needs to be human readable and automated updates to it should not crash
user edits.

-------------
Classes create a new data type. All of the types native in the system are
treated as classes. However, operator overloads are not supported. New methods
can be added to an object by defining it with the class name, but not for native
types such as int or string. Single inheritance is supported. There is no
"virtual" keyword. The symbols are are defined in the parent class are available
to the child class as well. If the child redefines a method or data item that
was previously defined in the parent, then the childs's version is used. The
parent version of the method or data element can be accessed using the parent's
name as part of the invocation if it was made public.

Constructors and destructors. If a class is intended to be inherited, then it
should establish reasonable defaults in it's base constructor. Since the public
and protected symbols are melded into the child class, those can be init by the
child class. However, private data needs to be accessible via getters and
setters if it is to be modified. In other words, passing parameters to the base
class constructor is not supported, but a new constructor can be defined simply
by defining it with the correct name.

--------------
When parsing a function definition, the return type and the types of any
parameters are not required. They are set when the function is declared.
