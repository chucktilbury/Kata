/**
 * @file scanner.h
 *
 * @brief Scanner header file. The items in this header must be implemented by
 * the scanner. Note that the library has support routines for common
 * operations that the scanner needs to perform. The scanner must implement a
 * stream of tokens. This stream is used to implement the look-ahead capability
 * of the parser. The default scanner implements it as a linked list. When
 * advance_token() is called, and the current token is at the end of the list,
 * then another token is added to the end of the list and made the current
 * token. When a rule fails to match, then the current token is rolled back to
 * the head of the list and that is made the current token so that the next
 * alternative rule can be attempted to match. Tokens are drawn from the list
 * instead of the input file as long as the end of the list is not reached. If
 * no rule can match the stream of tokens in the list, then there is an error
 * created and the error handler manipulates the list to implement error
 * recovery. If the rule is a match, then the tokens that are in the list up
 * to the current token are discarded from the list. Tokens that are important
 * to the match should have been copied to preserve their value.
 *
 * Error handlers need to have direct access to the token stream in order to
 * recover things like line number information.
 *
 * @author Chuck Tilbury (chucktilbury@gmail.com)
 * @version 0.0
 * @date 01-07-2024
 * @copyright Copyright (c) 2024
 */
#ifndef _SCANNER_H
#define _SCANNER_H

/*
 * This header is normally generated by the parser. The default scanner
 * implementes its own file as a sort of example.
 */
#include "keyword.h"

/**
 * @brief The parser expects a token to look like this.
 */
typedef struct {
    Str* str;       // String that caused the token to be recognized
    TokenType type; // Type of the token
    int line_no;    // Line number where the token was recognized
    int col_no;     // Column of the last character of the token
    const char* fname;  // File name where the token was taken
} Token;

/**
 * @brief Open a file for the scanner to read from. Files are expected to be
 * opened in a stack so that when a file is opened the input stream is
 * switched. Files are automatically closed when the last character is read.
 *
 * @param fname
 */
void open_file(const char* fname);

/**
 * @brief Get the token object. This returns the current token, which is a
 * global in the scanner. If the value of this token needs to be preserved,
 * then the token should be copied.
 *
 * @return Token*
 */
Token* get_token();

/**
 * @brief Do a deep copy of the given token pointer. All memory is duplicated.
 *
 * @param tok
 * @return Token*
 */
Token* copy_token(const Token* tok);

/**
 * @brief Make the next token in the stream the current token. If the token
 * before this one was the end of the input, then nothing happens and the
 * returned token is the end of input token. Returns the current token after
 * the advance happens.
 *
 * @return Token*
 */
Token* advance_token();

/**
 * @brief Consume the token queue from the beginning to the current token,
 * including the current token. This is called when a rule has been matched
 * and there is no need to keep that section of the token stream. This
 * advances the token stream and returns the new current token.
 *
 * @return Token*
 */
Token* consume_token();

/**
 * @brief Reset the token stream to the beginning. This is used when a rule
 * could not be matched and the token stream needs to be rewound to test the
 * next rule in a list of alternatives.
 *
 * @return Token*
 */
Token* reset_token();

/**
 * @brief Iterate the token queue. This is used by consumers that require raw
 * access to the token queue. That includes things like error reporting and
 * recovery. The first time that the iterator is called, the parameter needs
 * to be NULL. The current pointer in the queue is store there in order to
 * track the location in the queue. When there are no more elements in the
 * queue, then the return value is NULL.
 *
 * @param mark
 * @return Token*
 */
Token* iterate_tokens(void** mark);

/**
 * @brief Initialize the scanner data structures. This must be called before
 * any other calls into the scanner.
 */
void init_scanner();

/**
 * @brief Convert the binary token type to a string for display.
 *
 * @param type
 * @return const char*
 */
const char* tok_to_str(TokenType type);

#endif

